NOTE: '>' is path shown in the repo!

📌️ Algorithms:
1. Sorting Techniques | algorithms > sorting
2. KMP- Knuth Morris Pratt String Matching algorithm (How Pi Table works) | algorithm > string > pattern_matching

📌️️ Sorting:
1. Merge sort (divide and conquer) | single items are always sorted | 2 pointer to merge array
      Questions:
            - Count inversions
            - Smallest string

2. Quick Sort (divide and conquer) | pivot (always want to do quickly!) | left to placed pivot are all less | right items are all >
      Questions:
            - kth largest in array

📌️️ Questions:
1. Burglar Thief/Pick max adjacent number
2. Next Permutation problem (repeated many times)
3. One Edit distance/ Levenshtein problem
4. Minimum window substring (many similar questions)
5. Inversion of array (Similar to Merge sort)
NOTE: Minimum swaps to sort & count inversions are different question.
      - Count inversions is completely different thing(it asks to check num[i]>num[j] where i<j)
      - Whereas, Minimum swaps just asks to count minimum swaps required.
6. kth largest in array (Similar to Quick Sort)
7. Angry Birds problem - many problems, similar solution - monotonic Binary Search
8. Maximize the minimum - Game of Greed, monotonic Binary Search
      - (Maximize the minimum something) problem, check if taking values from (1....x) is possible - if yes it's monotonic Binary Search
9. Minimize the Maximum - Reading Books 🌟 
10. Min Pairs problem - 2 array find smallest absoulte difference picking one from each
11. Create all possible subsequences of string, array
12. Generate valid parenthesis
13. ** Backtracking(Must do) - longest_possible_route, NQueens, rat_maze, sudoku_solver
14. game_of_coins! (understanding how we are calculating all possible solutions and then deciding)
15. Reverse LinkedList in group of k! (k-reverse) - scratch/practice specific!
16. ** Next greater element, online stock span - important for stack! and when to use it!
17. Sliding window max - important to understand how queue helped to keep max present in window!
18. K smallest/greatest Questions indicate -> use Priority Q as it's better than sorting!
19. Finding running median - nice example of heap, priority_queue
20. **Merge k sorted list - intuition of min Heap is important, Also using comparator!

21. Swap sort - useful when 1 to N numbers given! - O(N)
22. Converting integer to binary quickly using bitset

23. Most frequent number in interval - imp to understand how we are keeping the range in map

24. Understanding Trie Data Structure - 'find string exists in array'

25. Do n-k-ladders dynamic programming all 3) types - imp to understand what we do in top-down(easy) & bottom-up approach

26. Longest common subsequence -> important to understand how we do 2D (diagonal movement if char matches)
- Also important to understand how we are priting the characters! (just backtracking :) )

27. Selling wines -> bottom up is important
- How we are relating recursion to iteration and grid understand is main logic

28. Longest alternative subsequence - O(n) approach (DP Problem)



------- ⭐️REVISE⭐️ --------

1. Longest Increasing Subsequence (optimizing from o(N^2) to O(NlogN))
      - Intuition- {1, 3, 6} -> 4 comes so {1, 3, 4} -> 4 replaces 6 by binary search! (Intuition)
      - The fact we have a vector sorted(ans) is reason we could use binary search here
      - ** If we want LIS array printed, we can't use it, as it will only check length! 
      - (Logic of replacement) Replacing 4 to 6 won't make any harm as until last of {} is not replaced we won't add more/ last one must be smallest possible
      - By DP we can print array as well -> O(N^2)

2. Longest Alternative Subsequence
      - Just make a graph going up and down
      - You just need to keep a check on up/down peaks that's all
      - Can be done in O(N), but looks like & can be done by DP as well
      

