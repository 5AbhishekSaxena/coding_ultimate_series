NOTE: '>' is path shown in the repo!

📌️ Algorithms:
1. Sorting Techniques | algorithms > sorting
2. KMP- Knuth Morris Pratt String Matching algorithm (How Pi Table works) | algorithm > string > pattern_matching

📌️️ Sorting:
1. Merge sort (divide and conquer) | single items are always sorted | 2 pointer to merge array
      Questions:
            - Count inversions
            - Smallest string

2. Quick Sort (divide and conquer) | pivot (always want to do quickly!) | left to placed pivot are all less | right items are all >
      Questions:
            - kth largest in array

📌️️ Questions:
1. Burglar Thief/Pick max adjacent number
2. Next Permutation problem (repeated many times)
3. One Edit distance/ Levenshtein problem
4. Minimum window substring (many similar questions)
5. Inversion of array (Similar to Merge sort)
NOTE: Minimum swaps to sort & count inversions are different question.
      - Count inversions is completely different thing(it asks to check num[i]>num[j] where i<j)
      - Whereas, Minimum swaps just asks to count minimum swaps required.
6. kth largest in array (Similar to Quick Sort)
7. Angry Birds problem - many problems, similar solution - monotonic Binary Search
8. Maximize the minimum - Game of Greed, monotonic Binary Search
      - (Maximize the minimum something) problem, check if taking values from (1....x) is possible - if yes it's monotonic Binary Search
9. Minimize the Maximum - Reading Books 🌟 
10. Min Pairs problem - 2 array find smallest absoulte difference picking one from each
11. Create all possible subsequences of string, array
12. Generate valid parenthesis
13. ** Backtracking(Must do) - longest_possible_route, NQueens, rat_maze, sudoku_solver
14. game_of_coins! (understanding how we are calculating all possible solutions and then deciding)
15. Reverse LinkedList in group of k! (k-reverse) - scratch/practice specific!
16. ** Next greater element, online stock span - important for stack! and when to use it!
17. Sliding window max - important to understand how queue helped to keep max present in window!
18. K smallest/greatest Questions indicate -> use Priority Q as it's better than sorting!
19. Finding running median - nice example of heap, priority_queue
20. **Merge k sorted list - intuition of min Heap is important, Also using comparator!

21. Swap sort - useful when 1 to N numbers given! - O(N)
22. Converting integer to binary quickly using bitset

23. Most frequent number in interval - imp to understand how we are keeping the range in map

24. Understanding Trie Data Structure - 'find string exists in array'

25. Do n-k-ladders dynamic programming all 3) types - imp to understand what we do in top-down(easy) & bottom-up approach

26. Longest common subsequence -> important to understand how we do 2D (diagonal movement if char matches)
- Also important to understand how we are priting the characters! (just backtracking :) )

27. Selling wines -> bottom up is important
- How we are relating recursion to iteration and grid understand is main logic

28. Longest alternative subsequence - O(n) approach (DP Problem)



------- ⭐️REVISE⭐️ + TUF_imp_revision.txt + TUF_graph_revision --------

1. Longest Increasing Subsequence (optimizing from o(N^2) to O(NlogN))
      - Intuition- {1, 3, 6} -> 4 comes so {1, 3, 4} -> 4 replaces 6 by binary search! (Intuition)
      - The fact we have a vector sorted(ans) is reason we could use binary search here
      - ** If we want LIS array printed, we can't use it, as it will only check length! 
      - (Logic of replacement) Replacing 4 to 6 won't make any harm as until last of {} is not replaced we won't add more/ last one must be smallest possible
      - By DP we can print array as well -> O(N^2)

2. Longest Alternative Subsequence
      - Just make a graph going up and down
      - You just need to keep a check on up/down peaks that's all
      - Can be done in O(N), but looks like & can be done by DP as well
      

3. Inversion Count/ Reverse Pair ( both similar question )
      - Basically we need to reduce complexity from O(N^2) to O(NlogN)
      - And things could be little better we have have 2 sorted array where we can check the requirement
      - And merge sort we have these arrays and hence we can easlily check it there
      - In Reverse Pair, the method where we check is important as that logic is little tricky yet easy!

4. (Easy Level) Product of 3 numbers
- 2 cases, 1st is easy - prod of last 3 (works for both all pos and all neg)
- 2nd case - if some negative - prod of first 2 (that will give max pos) and third num is last one (last one will be max of positive)

5. 🌟 Permutation Sequence (MUST DO)
- Although we can do next_permutation k times but that won't be efficient solution
- Hence we make use of math trick i.e if we have 123 then 1 {2, 3} -> this will be total 2 sequence (0-1) and hence if we have k=1 we know it will be 132
- Hence we pick 1 and recursively take 2 {3} or 3 {2} based on remaining number

6. Postfix Notation
- We can use stack to cover all conditions in postfix evaluation!
- Pop two numbers when operators occur and do operation and store result back in

7. Hash Table
- Creation of hash table. Use array to store keys as index but of limited size
- Hence collision will occur, so make linkedin list at each index of above array
- Keep hash function (%1000) optimized -> try/error

8. Subsequence Sum (BS problem - important to check question)
- Can be done using DP - gives TLE
- Greedy approach is difficult to reach!
- Constraint A[i] - A[j] = i - j, hence we conclude A[i] - i = A[j] - j, hence all same difference must be conslidated together

9. Perfect Squares (BS Problem, Math, DP)
- Important to understand how to solve a math problem using DP
- We can just send num and check if it can be further reduced using a sqauare and recurse!
- We can do memoization as it's an overlapping subproblems!
