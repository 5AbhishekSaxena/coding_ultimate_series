1. Inversion Count/ Reverse Pair ( both similar question )
- Basically we need to reduce complexity from O(N^2) to O(NlogN)
- And things could be little better we have have 2 sorted array where we can check the requirement
- And merge sort we have these arrays and hence we can easlily check it there
- ðŸŒŸ In Reverse Pair, the method where we check is important as that logic is little tricky yet easy!

2. Unique Path Problem (Google Interview)
- Use recursion for (2^N)
- Use DP for O(N^2)
- Use Optimised space in tabular
- ðŸŒŸ Use combinations - O(N) -> RRD, RDR...

3. Dutch National Flag Algorithm/ Sort colors/ Sort 0, 1, 2
- In a single pass it's required to be done, with constant space
- DNF says take 3 ptr - low, mid, high
- Low's left contains 0, high's right will contain 2
- swap mid[i] with left if 0, if 2-swap with high
- move ptr accordingly!

4. Linked List Cycle II
- Important to understand algorithm (If not known cant do the question)
- Important to understand how the same algo can work for 'Duplicate Element Question'
- 2 things are stated in algo 1) if there is cycle 2) start point of cycle
- After finding merger of fast and slow, just take another slow from head & keep moving 1 step (merger will be start of cycle)

5. Maximum Product Subarray
- Important to understand that array can have both -ve and 0
- Logic is to carry smallest and largest number possible everytimes
- So that if other - comes we can change that lowest to bigest or bigest to lowest(so it can become largest later when - comes again)
- Understand recursive approach in order to understand iterative(exactly same as recursion)
